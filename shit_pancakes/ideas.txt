
    """----> Hold the last 5 moves that we made"""
    previous_moves: list

    """----> Keep track of how many states have passed since we last moved each token."""

    """ If we know their token is chasing one of our tokens, try to cut in its path"""



        # def find_next_move_for_token(self, ally: Token, team_dict: dict):
    #     defeatable_tokens = self.generate_enemy_defeatable(team_dict)
    #     defeated_by_tokens = self.generate_enemy_defeated_by(team_dict)
    #     run_actions = []
    #     attack_actions = []
    #     scary_dudes = defeated_by_tokens[ally.symbol]
    #     closest_enemy = ally.find_closest_token(scary_dudes)
    #     # Find run actions
    #     if closest_enemy: 
    #         run_moves = self.token_run_away_from(ally, closest_enemy, team_dict)
    #         if run_moves:
    #             new_dist = Hex.dist(run_moves[0], ally.hex)
    #             if new_dist == 1 or new_dist > Hex.dist(ally.hex, closest_enemy.hex):
    #                 for move in run_moves:
    #                     new_action = Action.create_action_from_path(ally.hex, move)
    #                     run_actions.append(new_action)
    #     # Find attack actions
    #     if defeatable_tokens[ally.symbol]:
    #         for enemy in defeatable_tokens[ally.symbol]:
    #             attack_moves = find_attack_moves_for_token(team_dict, self.team_name, ally, enemy)
    #             if attack_moves:
    #                 for move in attack_moves:
    #                     new_action = Action.create_action_from_path(ally.hex, move)
    #                     attack_actions.append(new_action)
    #     # overlap = Action.find_overlap_actions(run_actions, attack_actions)
    #     return {ATTACK: attack_actions, RUN: run_actions} #, OVERLAP: overlap}
        

    # def generate_move_actions(self, team_dict: dict):
    #     attack_actions = []
    #     run_actions = []
    #     for ally in self.active_tokens:
    #         token_actions = self.find_next_move_for_token(ally, team_dict)
    #         # if token_actions[OVERLAP]:
    #         #     optimal_move_found = False
    #         #     for action in token_actions[OVERLAP]:
    #         #         if Hex.dist(action.from_hex, action.to_hex) == 1:
    #         #             optimal_move_found = True
    #         #             attack_actions.append(action)
    #         #     if optimal_move_found: continue
    #         attack_actions += token_actions[ATTACK]
    #         run_actions += token_actions[RUN]
    #     return {ATTACK: attack_actions, RUN: run_actions}



    # def improved_greedy(board: Board, team: Team):
#     enemy_team = board.team_upper if team.team_name == LOWER else board.team_lower
#     # Find best throw
#     best_throw_action, throw_dist_to_kill = team.determine_best_throw(board.team_dict)

#     # Find closest defeatable pair
#     closest_pair, pair_dist_to_kill = team.determine_closest_kill(board.team_dict)
#     closest_action = None

#     # If can throw directly on top of opponent token, throw
#     if best_throw_action and enemy_team.get_token_at(best_throw_action.to_hex):
#         return best_throw_action.to_tuple()
    
#     # Finding path between closest killable enemy token
#     if closest_pair:
#         path = astar_search(board.team_dict, team.team_name, closest_pair[0], closest_pair[1])
#         if path:
#             move_type = Rules.SLIDE if Hex.dist(path[0], path[1]) == 1 else Rules.SWING

#             closest_action = Action(action_type = move_type, from_hex=path[0], to_hex=path[1])
#         elif best_throw_action:
#             return best_throw_action

#     # attack_moves = team.generate_attack_actions(board.team_dict)
#     # run_actions = team.generate_run_actions(board.team_dict)

#     enemy_actions = enemy_team.generate_good_actions(board.team_dict)

#     if closest_action and enemy_actions:
#         U = []
#         for enemy_action in enemy_actions:
#             upper_action = closest_action if team.team_name == UPPER else enemy_action
#             lower_action = closest_action if team.team_name == LOWER else enemy_action
#             actions = {UPPER: upper_action, LOWER: lower_action}

#             new_board = Board(team_upper = board.team_upper, team_lower = board.team_lower)
#             new_board.successor(actions)
#             u = new_board.evaluate(team)
#             U.append(u)

#         s = sum(U)/len(U)
#         print(s)
#         '''
#         THINK ABOUT THIS VALUE
#         '''
#         if s > 0: 
#             return closest_action
    
#     return lol_main(board, team)



    # def evaluate(self, team: Team):
    #     score = 0
    #     opp_team = self.team_upper if (team.team_name == LOWER) else self.team_lower

    #     for token in team.active_tokens:
    #         score += self.evaluate_token(token, team.team_name)
        
    #     opp_total_active = len(opp_team.active_tokens)
    #     opp_num_invincible = opp_total_active
    #     for _s in Rules.VALID_SYMBOLS:
    #         our_same = team.get_tokens_of_type(_s)
    #         if len(our_same) == 0:
    #             continue
            
    #         opp_defeatable = opp_team.get_tokens_of_type(Token.BEATS_WHAT[_s])
    #         opp_defeated_by = opp_team.get_tokens_of_type(Token.WHAT_BEATS[_s])
    #         score += 2 - len(our_same) + len(opp_defeatable) - len(opp_defeated_by)
    #         opp_num_invincible -= len(opp_defeatable)
        

    #     # score += team.throws_remaining
    #     # score -= len(team.active_tokens)
    #     # Throws
    #     # score += (team.throws_remaining - opp_team.throws_remaining) * 5

    #     # Total opponent defeatable v/s invincible
    #     # score += (opp_total_active - opp_num_invincible) * 5
    #     score -= opp_num_invincible 
    #     score += team.throws_remaining 
    #     score += len(team.active_tokens) 

    #     # score -= ((Rules.MAX_THROWS - team.throws_remaining) - len(team.active_tokens)) * 5

        
    #     """
    #     CALCULATE DISTANCE TO ONE KILLABLE ENEMY TOKEN ONLY, NOT EVERY KILLABLE
    #     CALCULATE NUMBER OF ROCKS V OPP PAPERS, SCISSORS, ETC...
    #     EVERY PAIR OF FRIENDLY TOKENS NEXT TO EACH OTHER SHOULD GET BONUS SCORE
    #     """

    #     '''
    #     IMPLEMENT THIS
    #     '''
    #     # Difference between number of active opponent tokens versus throws left
    #     score += (Rules.MAX_THROWS - opp_team.throws_remaining) - len(opp_team.active_tokens) 
    #     # score -= (Rules.MAX_THROWS - team.throws_remaining) - len(team.active_tokens) 

    #     return score

    # def compute_utility_matrix(self, team: Team):
    #     # generate all pairings of actions for the 2 players 
    #     upper_actions = self.team_upper.generate_actions(self.team_dict)
    #     lower_actions = self.team_lower.generate_actions(self.team_dict)
    #     # actions = itertools.product(upper_actions, lower_actions)
        
    #     # for each pairing of actions, create a new "board" 
    #     V = []
    #     for i in range(len(upper_actions)):
    #         V_i = []
    #         for j in range(len(lower_actions)):
    #             actions_pair = {UPPER: upper_actions[i], LOWER: lower_actions[j]}
    #             new_board = Board(team_upper = self.team_upper, team_lower = self.team_lower)
    #             new_board.successor(actions_pair)
    #             V_i.append((new_board, actions_pair))
    #         V.append(V_i)
        
    #     # Evaluate the board
    #     Z_ups = []
    #     Z_lws = []
    #     actions_matrix = []
    #     for i in range(len(V)):
    #         Z_ups_i = []
    #         Z_lws_i = []
    #         # Z_i = []
    #         A_i = []
    #         for j in range(len(V[i])):
    #             # Z_ij = []
    #             state = V[i][j][0]
    #             actions_pair = V[i][j][1]
    #             team_upper_score = state.evaluate(state.team_upper)
    #             team_lower_score = state.evaluate(state.team_lower)

    #             # Z_ij = (team_upper_score, team_lower_score)
    #             # Z_ij = team_upper_score - team_lower_score if team.team == UPPER else team_lower_score - team_upper_score

    #             Z_ups_i.append(team_upper_score)
    #             Z_lws_i.append(team_lower_score)
    #             # Z_i.append(Z_ij)
    #             A_i.append(actions_pair)

    #         # Z.append(Z_i)
    #         Z_ups.append(Z_ups_i)
    #         Z_lws.append(Z_lws_i)
    #         actions_matrix.append(A_i)


    #     """PRUNE OUT ALL STRICTLY DOMINATED STRATEGIES IN THIS MATRIX FOR BOTH PLAYERS"""
    #     """CHECK FOR WEAKLY DOMINATED STRATEGIES"""

    #     Z = {UPPER: Z_ups, LOWER: Z_lws}
    #     # print_pretty(Z)
    #     return Z, actions_matrix



    # def find_nash_equilibrium(self):

    #     return nash_equilibrium